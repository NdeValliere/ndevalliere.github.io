<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>
		<div id="container"></div>

		<script src="jsm/libs/ammo.wasm.js"></script>

		<script type="importmap">
			{
				"imports": {
					"three": "./build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';
			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { STLLoader } from 'three/addons/loaders/STLLoader.js';

			// Graphics variables
			let container;
			let camera, controls, scene, renderer;
			let textureLoader;
			let mouseColorVariable = 0xFDF351; // Initial color

			const clock = new THREE.Clock();


			// Physics variables
			const gravityConstant = - 9.8;
			let physicsWorld;
			const rigidBodies = [];
			const margin = 0.05;
			let transformAux1;


			Ammo().then( function ( AmmoLib ) {

				Ammo = AmmoLib;

				init();
				animate();
			} );


			function init() {

				initGraphics();
				initPhysics();
				createObjects();
			}

			function initGraphics() {

				container = document.getElementById( 'container' );

				camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 0.2, 2000 );

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x33278A );

				camera.position.set( 0.1, -55, 0 );

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.shadowMap.enabled = true;
				container.appendChild( renderer.domElement );

				controls = new OrbitControls( camera, renderer.domElement );
				controls.target.set( 0, 0, 0 );
				controls.update();

				textureLoader = new THREE.TextureLoader();

				const ambientLight = new THREE.AmbientLight( mouseColorVariable, 10 ); // Use mouseColorVariable
				scene.add( ambientLight );

				window.addEventListener( 'resize', onWindowResize );
			}


			function initPhysics() {

			    // Physics configuration
			    const collisionConfiguration = new Ammo.btSoftBodyRigidBodyCollisionConfiguration();
			    const dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration);
			    const broadphase = new Ammo.btDbvtBroadphase();
			    const solver = new Ammo.btSequentialImpulseConstraintSolver();
			    const softBodySolver = new Ammo.btDefaultSoftBodySolver();
			    
			    // Set gravity to zero
			    const gravity = new Ammo.btVector3(0, 0, 0); // Set gravity to (0, 0, 0)
			    physicsWorld = new Ammo.btSoftRigidDynamicsWorld(dispatcher, broadphase, solver, collisionConfiguration, softBodySolver);
			    physicsWorld.setGravity(gravity);
			    physicsWorld.getWorldInfo().set_m_gravity(gravity);

			    transformAux1 = new Ammo.btTransform();

			}

			function createObjects() {
			    const pos = new THREE.Vector3();
			    const quat = new THREE.Quaternion();
			    
				const stlLoader = new STLLoader();
				stlLoader.load('./models/stl/ox-logo-4.stl', function (geometry) {
				    
				    // Calculate complementary color
				    const complementaryColor = calculateComplementaryColor(scene.background.getHex());

				    // Create material with complementary color
				    const material = new THREE.MeshPhongMaterial({ color: complementaryColor, specular: complementaryColor, shininess: 0 });
				    const stlModel = new THREE.Mesh(geometry, material);

				    stlModel.position.set(0, -5, 0);

				    // Apply physics to the instance
				    const stlMass = 10;
				    const stlShape = new Ammo.btConvexHullShape();
				    const vertices = geometry.attributes.position.array;
				    for (let j = 0; j < vertices.length; j += 3) {
				        const vertex = new Ammo.btVector3(vertices[j], vertices[j + 1], vertices[j + 2]);
				        stlShape.addPoint(vertex);
				    }
				    const stlQuaternion = new THREE.Quaternion(); // Adjust rotation as needed
				    createRigidBody(stlModel, stlShape, stlMass, stlModel.position, stlQuaternion);

				    // Add the instance to the scene
				    scene.add(stlModel);
				        // Listen for mousemove event to update the color dynamically
				    window.addEventListener('mousemove', function(event) {
				        const complementaryColor = calculateComplementaryColor(scene.background.getHex());
				        stlModel.material.color.setHex(complementaryColor);
				        stlModel.material.specular.setHex(complementaryColor);
				    });
				});

				function calculateComplementaryColor(hexColor) {
				    // Convert hex color to RGB components
				    const r = (hexColor >> 16) & 0xff;
				    const g = (hexColor >> 8) & 0xff;
				    const b = hexColor & 0xff;

				    // Calculate complementary color by subtracting each RGB component from 255
				    const complementaryR = 255 - r;
				    const complementaryG = 255 - g;
				    const complementaryB = 255 - b;

				    // Combine RGB components into a single integer
				    return (complementaryR << 16) | (complementaryG << 8) | complementaryB;
				}


			    // Ground
			    pos.set(0, -95, 0);
			    quat.set(0, 0, 0, 1);
			    const ground = createParalellepiped(40, 1, 80, 0, pos, quat, new THREE.MeshPhongMaterial({ color: 0xFFFFFF,transparent: true, opacity: 0}));

			    // Boundary walls
			    const wallThickness = 0.5;
			    const wallHeight = 100;
			    const wallMaterial = new THREE.MeshPhongMaterial({ color: 0x999999, transparent: true, opacity: 0});
			    const walls = [
			        { position: new THREE.Vector3(0, -45, -40), width: 40, height: wallHeight, depth: wallThickness }, // Front wall
			        { position: new THREE.Vector3(0, -45, 40), width: 40, height: wallHeight, depth: wallThickness }, // Back wall
			        { position: new THREE.Vector3(-20, -45, 0), width: wallThickness, height: wallHeight, depth: 80 }, // Left wall
			        { position: new THREE.Vector3(20, -45, 0), width: wallThickness, height: wallHeight, depth: 80 }, // Right wall
			        { position: new THREE.Vector3(0, wallHeight / 20, 0), width: 40, height: wallThickness, depth: 80 } // Top boundary
			    ];

			    walls.forEach(wall => {
			        const { position, width, height, depth } = wall;
			        const wallGeometry = new THREE.BoxGeometry(width, height, depth);
			        const wallMesh = createParalellepiped(width, height, depth, 0, position, quat, wallMaterial);
			        scene.add(wallMesh);
			    });
			}


			function createParalellepiped( sx, sy, sz, mass, pos, quat, material ) {

				const threeObject = new THREE.Mesh( new THREE.BoxGeometry( sx, sy, sz, 1, 1, 1 ), material );
				const shape = new Ammo.btBoxShape( new Ammo.btVector3( sx * 0.5, sy * 0.5, sz * 0.5 ) );
				shape.setMargin( margin );

				createRigidBody( threeObject, shape, mass, pos, quat );

				return threeObject;
			}

			function createRigidBody( threeObject, physicsShape, mass, pos, quat ) {

				threeObject.position.copy( pos );
				threeObject.quaternion.copy( quat );

				const transform = new Ammo.btTransform();
				transform.setIdentity();
				transform.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) );
				transform.setRotation( new Ammo.btQuaternion( quat.x, quat.y, quat.z, quat.w ) );
				const motionState = new Ammo.btDefaultMotionState( transform );

				const localInertia = new Ammo.btVector3( 0, 0, 0 );
				physicsShape.calculateLocalInertia( mass, localInertia );

				const rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, physicsShape, localInertia );
				const body = new Ammo.btRigidBody( rbInfo );

				threeObject.userData.physicsBody = body;

				scene.add( threeObject );

				if ( mass > 0 ) {

					rigidBodies.push( threeObject );

					// Disable deactivation
					body.setActivationState( 4 );

				}

				physicsWorld.addRigidBody( body );

			}


			//Interact with bricks
			window.addEventListener('pointermove', onDocumentMouseDown);

			function onDocumentMouseDown(event) {
				// console.log("touching");
			    event.preventDefault();
		        // Update mouseColorVariable based on mouse position
		        const normalizedX = event.clientX / window.innerWidth; // Normalize mouse X position
		        const normalizedY = event.clientY / window.innerHeight; // Normalize mouse Y position

		        const r = normalizedX * 255;
		        const g = (1 - normalizedY) * 255; // Invert Y position for green component
		        const b = 100; // Fixed blue component

		        mouseColorVariable = (r << 16) | (g << 8) | b; // Combine RGB components into a single integer
		        scene.background.setHex(mouseColorVariable); // Update background color
		        const ambientLight = scene.getObjectByName('ambientLight');
		        ambientLight.color.setHex(mouseColorVariable); // Update ambient light color
		    }

			// function applyForceToBrick(brick) {
			//     const force = new THREE.Vector3(0, 60, 0); // Customize the force as needed
			//     const pointOfImpact = new THREE.Vector3(); // Customize the point of impact as needed

			//     const physicsBody = brick.userData.physicsBody;
			//     if (physicsBody) {
			//         const ammoForce = new Ammo.btVector3(force.x, force.y, force.z);
			//         const ammoPoint = new Ammo.btVector3(pointOfImpact.x, pointOfImpact.y, pointOfImpact.z);
			//         physicsBody.applyImpulse(ammoForce, ammoPoint);
			//     }
			// }

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function animate() {
				requestAnimationFrame( animate );
				render();
			}

			function render() {
				const deltaTime = clock.getDelta();
				updatePhysics( deltaTime );
				renderer.render( scene, camera );
			}

			function updatePhysics( deltaTime ) {

				// Step world
				physicsWorld.stepSimulation( deltaTime, 10 );

				// Update rigid bodies
				for ( let i = 0, il = rigidBodies.length; i < il; i ++ ) {

					const objThree = rigidBodies[ i ];
					const objPhys = objThree.userData.physicsBody;
					const ms = objPhys.getMotionState();
					if ( ms ) {

						ms.getWorldTransform( transformAux1 );
						const p = transformAux1.getOrigin();
						const q = transformAux1.getRotation();
						objThree.position.set( p.x(), p.y(), p.z() );
						objThree.quaternion.set( q.x(), q.y(), q.z(), q.w() );

					}

				}

			}

		</script>

	</body>
</html>
